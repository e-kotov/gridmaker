% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_grid.R
\name{create_grid}
\alias{create_grid}
\title{Create a standard-compliant spatial grid with INSPIRE IDs}
\usage{
create_grid(
  grid_extent,
  cellsize_m,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  ...
)
}
\arguments{
\item{grid_extent}{A spatial object to define the grid's extent. Can be an
\code{sf} or \code{sfc} object, a 2x2 \code{bbox} matrix, or a numeric vector of
\code{c(xmin, ymin, xmax, ymax)}.}

\item{cellsize_m}{A single integer representing the grid cell size in metres
(e.g., 1000 for a 1 km grid).}

\item{crs}{The coordinate reference system (CRS) for the output grid.
Accepts various formats handled by \code{sf::st_crs()}: an integer or numeric
EPSG code (e.g., \code{3035}), a string representation like \code{"epsg:3035"}, or
a \code{crs} object. If \code{NULL} (default), the CRS is inherited from
\code{grid_extent}. If \code{grid_extent} also lacks a CRS, the function will stop
with an error.}

\item{output_type}{The class of the output object: \code{"sf_polygons"} (default) creates
a spatial object with polygon geometries, \code{"sf_points"} creates an \code{sf}
object with point geometries, and \code{"dataframe"} creates a data frame with
grid cell centroid coordinates (\code{X_centroid}, \code{Y_centroid}).}

\item{clip_to_input}{A logical value. If \code{TRUE}, the grid is filtered to
include only cells that intersect the \code{grid_extent}. This does not cut
cell geometries.}

\item{use_convex_hull}{A logical value. If \code{TRUE} and \code{clip_to_input} is
\code{TRUE}, the grid is clipped to the convex hull of the input geometry,
which can be faster and simpler than using a complex polygon.}

\item{buffer_m}{A numeric value. If \code{clip_to_input} is \code{TRUE}, this specifies
a buffer distance in metres to apply to the \code{grid_extent} geometry before
clipping. Defaults to \code{0} (no buffer).}

\item{id_format}{A character string specifying which grid cell IDs to generate.
Options are \code{"both"} (default), \code{"long"}, \code{"short"}, or \code{"none"}.}

\item{include_llc}{A logical value. If \code{TRUE} (default), columns for the
lower-left corner coordinates (\code{X_LLC}, \code{Y_LLC}) of each cell are included
in the output.}

\item{point_type}{A character string, used only when \code{output_type = "sf_points"}.
Determines the location of the points: \code{"centroid"} (default) for the center of the cell, or \code{"llc"} for the lower-left corner.}

\item{parallel}{Controls parallel execution. Options are:
\itemize{
\item \strong{\code{'auto'} (default):} Automatically detects and uses a configured
\code{mirai} or \code{future} backend if one is available. If both are set, it
prefers the one with more available workers and issues a warning. If
neither is configured, it runs sequentially.
\item \strong{\code{TRUE}:} Forces the function to attempt parallel execution. It
will raise an error if a valid parallel backend (with >1 worker) is
not configured.
\item \strong{\code{FALSE}:} Forces the function to run in single-threaded
sequential mode.
}
For parallelism, you must configure a backend \emph{before} calling this
function, for example: \code{mirai::daemons(4)} or \code{future::plan("multisession")}.}

\item{quiet}{logical value. If ‘TRUE’, all progress messages and progress bars are suppressed. Defaults to ‘FALSE’.}

\item{dsn}{An optional character string for the data source name (e.g.,
file path). If provided, the grid is written to this file instead of
being returned as an object.}

\item{layer}{An optional character string for the layer name. When writing
to a file (i.e., when \code{dsn} is specified), if \code{layer} is \code{NULL}, it
defaults to the file name of the data source. This is useful for formats
like GeoPackage, but may be ignored by others (e.g., GeoJSON).}

\item{...}{Additional arguments passed to specific backend handlers. For
streaming backends (\code{mirai} or sequential), this can include
\code{max_cells_per_chunk} to control memory usage.}
}
\value{
If \code{dsn} is \code{NULL} (the default), an \code{sf} object or \code{data.frame}
representing the grid. If \code{dsn} is specified, the function writes the grid
to a file and returns \code{invisible(NULL)}.
}
\description{
{
This function generates a regular spatial grid aligned to the CRS origin.
It combines high performance for large areas (using \code{sfheaders}) with a
flexible and robust set of features for input handling and output formatting,
including INSPIRE-compliant grid IDs and automatic parallel processing with
\code{mirai} and \code{future} backends. When \code{dsn} is provided, the grid is written
directly to a file and the function returns \code{NULL} invisibly.}
}
\examples{
library(sf)
# Load the sample data from the sf package
nc_raw <- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)

# Define target projected CRS and cell size
target_crs <- 5070 # NAD83 / Conus Albers
cellsize_m <- 10000 # 10 km

# Project the data
nc <- st_transform(nc_raw, target_crs)

# Create a grid covering the data
nc_grid <- create_grid(
  grid_extent = nc,
  cellsize_m = cellsize_m,
  output_type = "sf_polygons",
  clip_to_input = TRUE
)

head(nc_grid, 3)
}
