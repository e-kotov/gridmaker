% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/async_write_to_disk.R
\name{create_grid_and_stream_mirai}
\alias{create_grid_and_stream_mirai}
\title{Create a standard-compliant spatial grid and stream it to a file using mirai}
\usage{
create_grid_and_stream_mirai(
  grid_extent,
  cellsize_m,
  crs = NULL,
  dsn,
  layer,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  include_llc = TRUE,
  point_type = "centroid",
  quiet = FALSE,
  max_cells_per_chunk = NULL
)
}
\arguments{
\item{grid_extent}{A spatial object to define the grid's extent. Can be an
\code{sf} or \code{sfc} object, a 2x2 \code{bbox} matrix, or a numeric vector of
\code{c(xmin, ymin, xmax, ymax)}.}

\item{cellsize_m}{A single integer representing the grid cell size in metres
(e.g., 1000 for a 1 km grid).}

\item{crs}{The coordinate reference system (CRS) for the output grid.
Accepts various formats handled by \code{sf::st_crs()}: an integer or numeric
EPSG code (e.g., \code{3035}), a string representation like \code{"epsg:3035"}, or
a \code{crs} object. If \code{NULL} (default), the CRS is inherited from
\code{grid_extent}. If \code{grid_extent} also lacks a CRS, the function will stop
with an error.}

\item{dsn}{A character string for the data source name (e.g., file path).}

\item{layer}{A character string for the layer name.}

\item{output_type}{The class of the output object: \code{"sf_polygons"} (default) creates
a spatial object with polygon geometries, \code{"sf_points"} creates an \code{sf}
object with point geometries, and \code{"dataframe"} creates a data frame with
grid cell centroid coordinates (\code{X_centroid}, \code{Y_centroid}).}

\item{clip_to_input}{A logical value. If \code{TRUE}, the grid is filtered to
include only cells that intersect the \code{grid_extent}. This does not cut
cell geometries.}

\item{use_convex_hull}{A logical value. If \code{TRUE} and \code{clip_to_input} is
\code{TRUE}, the grid is clipped to the convex hull of the input geometry,
which can be faster and simpler than using a complex polygon.}

\item{buffer_m}{A numeric value. If \code{clip_to_input} is \code{TRUE}, this specifies
a buffer distance in metres to apply to the \code{grid_extent} geometry before
clipping. Defaults to \code{0} (no buffer).}

\item{id_format}{A character string specifying which grid cell IDs to generate.
Options are \code{"both"} (default), \code{"long"}, \code{"short"}, or \code{"none"}.}

\item{include_llc}{A logical value. If \code{TRUE} (default), columns for the
lower-left corner coordinates (\code{X_LLC}, \code{Y_LLC}) of each cell are included
in the output.}

\item{point_type}{A character string, used only when \code{output_type = "sf_points"}.
Determines the location of the points: \code{"centroid"} (default) for the center of the cell, or \code{"llc"} for the lower-left corner.}

\item{quiet}{logical value. If ‘TRUE’, all progress messages and progress bars are suppressed. Defaults to ‘FALSE’.}

\item{max_cells_per_chunk}{An optional integer. If provided, the function will
create processing chunks that contain approximately this many grid cells at most.
This provides more granular control over memory usage than the default tiling
strategy. If \code{NULL} (the default), tiling is based on the number of workers.}
}
\description{
This function generates a regular spatial grid and writes it directly to a file
using a memory-efficient asynchronous pipeline with the \code{mirai} backend.
Chunks are generated in parallel and the \code{.promise} argument of \code{mirai_map}
is used to write chunks to disk sequentially as they become available.
}
\note{
This function requires that \code{mirai} daemons are already configured and running
(e.g., via \code{mirai::daemons(4)}). It also requires the \code{promises} and \code{later}
packages.
}
