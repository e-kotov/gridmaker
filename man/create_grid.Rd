% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_grid.R
\name{create_grid}
\alias{create_grid}
\title{Create a standard-compliant spatial grid with INSPIRE IDs}
\usage{
create_grid(
  grid_extent,
  cellsize_m,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  ...
)
}
\arguments{
\item{grid_extent}{A spatial object to define the grid's extent. Can be an
\code{sf} or \code{sfc} object, a 2x2 \code{bbox} matrix, or a numeric vector of
\code{c(xmin, ymin, xmax, ymax)}.}

\item{cellsize_m}{A single integer representing the grid cell size in metres
(e.g., 1000 for a 1 km grid).}

\item{crs}{The coordinate reference system (CRS) for the output grid.
Accepts various formats handled by \code{sf::st_crs()}: an integer or numeric
EPSG code (e.g., \code{3035}), a string representation like \code{"epsg:3035"}, or
a \code{crs} object. If \code{NULL} (default), the CRS is inherited from
\code{grid_extent}. If \code{grid_extent} also lacks a CRS, the function will stop
with an error.}

\item{output_type}{The class of the output object: \code{"sf_polygons"} (default) creates
a spatial object with polygon geometries, \code{"sf_points"} creates an \code{sf}
object with point geometries, and \code{"dataframe"} creates a data frame with
grid cell centroid coordinates (\code{X_centroid}, \code{Y_centroid}).}

\item{clip_to_input}{A logical value. If \code{TRUE}, the grid is filtered to
include only cells that intersect the \code{grid_extent}. This does not cut
cell geometries.}

\item{use_convex_hull}{A logical value. If \code{TRUE} and \code{clip_to_input} is
\code{TRUE}, the grid is clipped to the convex hull of the input geometry,
which can be faster and simpler than using a complex polygon.}

\item{buffer_m}{A numeric value. If \code{clip_to_input} is \code{TRUE}, this specifies
a buffer distance in metres to apply to the \code{grid_extent} geometry before
clipping. Defaults to \code{0} (no buffer).}

\item{id_format}{A character string specifying which grid cell IDs to generate.
Options are \code{"both"} (default), \code{"long"}, \code{"short"}, or \code{"none"}.}

\item{include_llc}{A logical value. If \code{TRUE} (default), columns for the
lower-left corner coordinates (\code{X_LLC}, \code{Y_LLC}) of each cell are included
in the output.}

\item{point_type}{A character string, used only when \code{output_type = "sf_points"}.
Determines the location of the points: \code{"centroid"} (default) for the center of the cell, or \code{"llc"} for the lower-left corner.}

\item{parallel}{Controls parallel execution. Options are:
\itemize{
\item \strong{\code{'auto'} (default):} Automatically detects and uses a configured
\code{mirai} or \code{future} backend if one is available. If both are set, it
prefers the one with more available workers and issues a warning. If
neither is configured, it runs sequentially.
\item \strong{\code{TRUE}:} Forces the function to attempt parallel execution. It
will raise an error if a valid parallel backend (with >1 worker) is
not configured.
\item \strong{\code{FALSE}:} Forces the function to run in single-threaded
sequential mode.
}
For parallelism, you must configure a backend \emph{before} calling this
function, for example: \code{mirai::daemons(4)} or \code{future::plan("multisession")}.
workers often provide the best trade-off between speed and overhead.
The function automatically limits the number of active workers for small grids
to minimize overhead, unless \code{options(gridmaker.tile_multiplier)} is explicitly set.}

\item{quiet}{logical value. If ‘TRUE’, all progress messages and progress bars are suppressed. Defaults to ‘FALSE’.}

\item{dsn}{The destination for the output grid, passed directly to
\code{sf::st_write}. This can be a file path (e.g., \code{"path/to/grid.gpkg"})
or a database connection string. If \code{dsn} is provided, the grid is
written to the specified location instead of being returned as an object.}

\item{layer}{The name of the grid layer, passed directly to \code{sf::st_write}.
Its interpretation depends on the destination driver. For a GeoPackage
file, this will be the layer name. If \code{dsn} is a file path and \code{layer} is
not specified, it defaults to the file's base name.}

\item{max_memory_gb}{A numeric value. Maximum memory in gigabytes to use for grid creation. Default is NULL, in which case there is an automatic limit of available system memory. The available memory detection may fail on certain HPC (High Performance Computing) systems where jobs are allocated a fixed amount of memory that is less than the total system memory of the allocated node.}

\item{...}{Additional arguments passed to specific backend handlers. For
streaming backends (\code{mirai} or sequential), this can include
\code{max_cells_per_chunk} to control memory usage.}
}
\value{
If \code{dsn} is \code{NULL} (the default), an \code{sf} object or \code{data.frame}
representing the grid. If \code{dsn} is specified, the function writes the grid
to a file and returns \code{invisible(dsn)}.
}
\description{
{
This function generates a regular spatial grid aligned to the CRS origin.
It combines high performance for large areas (using \code{sfheaders}) with a
flexible and robust set of features for input handling and output formatting,
including INSPIRE-compliant grid IDs and automatic parallel processing with
\code{mirai} and \code{future} backends. When \code{dsn} is provided, the grid is written
directly to a file and the function returns the path to the created data
source (\code{dsn}) invisibly.}
}
\examples{
library(sf)
# Load the sample data from the sf package
nc_raw <- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)

# Define target projected CRS and cell size
target_crs <- 5070 # NAD83 / Conus Albers
cellsize_m <- 10000 # 10 km

# Project the data
nc <- st_transform(nc_raw, target_crs)

# Create a grid covering the data
nc_grid <- create_grid(
  grid_extent = nc,
  cellsize_m = cellsize_m,
  output_type = "sf_polygons",
  clip_to_input = TRUE
)

head(nc_grid, 3)
}
