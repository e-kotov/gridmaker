% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inspire_grid.R, R/inspire_grid_from_ids.R
\name{inspire_grid}
\alias{inspire_grid}
\alias{inspire_grid.sf}
\alias{inspire_grid.sfc}
\alias{inspire_grid.bbox}
\alias{inspire_grid.numeric}
\alias{inspire_grid.matrix}
\alias{inspire_grid.character}
\alias{inspire_grid_from_extent}
\alias{inspire_grid_from_ids}
\title{Create or Reconstruct an INSPIRE Grid}
\usage{
inspire_grid(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

\method{inspire_grid}{sf}(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

\method{inspire_grid}{sfc}(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

\method{inspire_grid}{bbox}(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

\method{inspire_grid}{numeric}(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

\method{inspire_grid}{matrix}(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

\method{inspire_grid}{character}(
  x,
  cellsize_m = NULL,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "llc",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

inspire_grid_from_extent(
  grid_extent,
  cellsize_m,
  crs = NULL,
  output_type = "sf_polygons",
  clip_to_input = FALSE,
  use_convex_hull = FALSE,
  buffer_m = 0,
  id_format = "both",
  axis_order = "NE",
  include_llc = TRUE,
  point_type = "centroid",
  parallel = "auto",
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  max_memory_gb = NULL,
  include_rat = FALSE,
  ...
)

inspire_grid_from_ids(
  ids,
  point_type = c("llc", "centroid"),
  output_type = c("sf_polygons", "sf_points", "dataframe"),
  include_llc = TRUE,
  id_format = c("both", "long", "short"),
  axis_order = c("NE", "EN"),
  quiet = FALSE,
  dsn = NULL,
  layer = NULL,
  ...
)
}
\arguments{
\item{x}{The main input object: either a spatial object (extent) or a character vector (INSPIRE IDs).}

\item{cellsize_m}{A single integer representing the grid cell size in metres
(e.g., 1000 for a 1 km grid). Required for spatial inputs.}

\item{crs}{The coordinate reference system (CRS) for the output grid.
Accepts various formats handled by \code{sf::st_crs()}: an integer or numeric
EPSG code (e.g., \code{3035}), a string representation like \code{"epsg:3035"}, or
a \code{crs} object. If \code{NULL} (default), the CRS is inherited from
the spatial input. If the input also lacks a CRS, the function will stop
with an error.}

\item{output_type}{The class of the output object: \code{"sf_polygons"} (default) creates
a spatial object with polygon geometries, \code{"sf_points"} creates an \code{sf}
object with point geometries, \code{"dataframe"} creates a data frame with
grid cell centroid coordinates (\code{X_centroid}, \code{Y_centroid}), and
\code{"spatraster"} creates a \code{terra::SpatRaster} object with grid cell IDs
stored as factor levels (Raster Attribute Table).
\strong{Note:} \code{"spatraster"} is only supported by \code{inspire_grid_from_extent()},
not by \code{inspire_grid_from_ids()}.}

\item{clip_to_input}{A logical value. If \code{TRUE}, the grid is filtered to
include only cells that intersect the spatial input. This does not cut
cell geometries.}

\item{use_convex_hull}{A logical value. If \code{TRUE} and \code{clip_to_input} is
\code{TRUE}, the grid is clipped to the convex hull of the input geometry,
which can be faster and simpler than using a complex polygon.}

\item{buffer_m}{A numeric value. If \code{clip_to_input} is \code{TRUE}, this specifies
a buffer distance in metres to apply to the spatial input before clipping.
Defaults to \code{0} (no buffer).}

\item{id_format}{A character string specifying which grid cell IDs to generate.
Options are \code{"both"} (default), \code{"long"}, \code{"short"}, or \code{"none"}.}

\item{axis_order}{A character string specifying the coordinate order for the
output Short INSPIRE IDs. This parameter is \strong{only used when \code{id_format} is
\code{"short"} or \code{"both"}}. It can be one of:
\itemize{
\item \code{"NE"} (the default) to produce the format \verb{\{cellsize\}N\{y\}E\{x\}}.
\item \code{"EN"} to produce the format \verb{\{cellsize\}E\{x\}N\{y\}} (e.g. this format is used in \href{https://www.dst.dk/en/TilSalg/produkter/geodata/kvadratnet}{Danish national grid}).
}}

\item{include_llc}{A logical value. If \code{TRUE} (default), columns for the
lower-left corner coordinates (\code{X_LLC}, \code{Y_LLC}) of each cell are included
in the output.}

\item{point_type}{A character string determining the location of the points
when \code{output_type = "sf_points"}: \code{"centroid"} for the center of the cell,
or \code{"llc"} for the lower-left corner. Default is \code{"llc"}.}

\item{parallel}{Controls parallel execution. Options are:
\itemize{
\item \strong{\code{'auto'} (default):} Automatically detects and uses a configured
\code{mirai} or \code{future} backend if one is available. If both are set, it
prefers the one with more available workers and issues a warning. If
neither is configured, it runs sequentially.
\item \strong{\code{TRUE}:} Forces the function to attempt parallel execution. It
will raise an error if a valid parallel backend (with >1 worker) is
not configured.
\item \strong{\code{FALSE}:} Forces the function to run in single-threaded
sequential mode.
}
For parallelism, you must configure a backend \emph{before} calling this
function, for example: \code{mirai::daemons(8)} or \code{future::plan("multisession", workers = 8)}.
\strong{Performance tip:} Benchmarks show 4-8 workers provide optimal performance for most
grid sizes. Using >8 workers typically yields diminishing returns due to I/O bottlenecks.
The function automatically limits active workers for small grids to minimize overhead:
<50k cells use max 4 workers, <500k cells use max 8 workers, <2M cells use max 16 workers.
This automatic limiting can be overridden by setting \code{options(gridmaker.tile_multiplier)}.
\strong{Note:} Parallel processing is not supported when \code{output_type = "spatraster"}.
Raster output will always run sequentially.}

\item{quiet}{Logical value. If \code{TRUE}, all progress messages and progress bars are suppressed. Defaults to \code{FALSE}.}

\item{dsn}{The destination for the output grid. For sf objects, this is passed to
\code{sf::st_write}. For \code{spatraster} output, this uses \code{terra::writeRaster}.
This can be a file path (e.g., \code{"path/to/grid.gpkg"} for vector data or
\code{"path/to/grid.tif"} for raster data) or a database connection string.
If \code{dsn} is provided, the grid is written to the specified location
instead of being returned as an object.

\strong{Supported vector formats for chunked disk writes:}
\itemize{
\item \code{.gpkg} (GeoPackage) - \strong{Recommended} - Best balance of speed, compatibility, and modern features
\item \code{.shp} (Shapefile) - Widely used, fast writes, but has limitations (10-char field names, 2GB limit)
\item \code{.geojson}, \code{.json} (GeoJSON) - Web-friendly, works but slower for large grids
\item \code{.geojsonl}, \code{.geojsonseq} (GeoJSONSeq) - Newline-delimited GeoJSON
\item \code{.sqlite} (SQLite/SpatiaLite) - Database format (GeoPackage is built on SQLite)
\item \code{.fgb} (FlatGeobuf) - Cloud-optimized format
\item \code{.gdb} (OpenFileGDB) - ESRI FileGDB format
\item \code{.csv}, \code{.tsv}, \code{.txt} (for dataframe output only)
}

Other formats not listed have not been tested and will generate a warning.}

\item{layer}{The name of the grid layer, passed directly to \code{sf::st_write}.
Its interpretation depends on the destination driver. For a GeoPackage
file, this will be the layer name. If \code{dsn} is a file path and \code{layer} is
not specified, it defaults to the file's base name.}

\item{max_memory_gb}{A numeric value. Maximum memory in gigabytes to use for grid creation. Default is \code{NULL}, in which case there is an automatic limit based on \strong{available free system memory} (not total system RAM). Using this argument allows manual override, which is recommended on certain HPC (High Performance Computing) systems where jobs are allocated a fixed amount of memory that is less than the total free memory of the allocated node.}

\item{include_rat}{Logical. If \code{TRUE}, generate a Raster Attribute Table (RAT)
mapping numeric cell IDs to INSPIRE grid ID strings. Default is \code{FALSE}.

\strong{What is a RAT?} A Raster Attribute Table stores metadata (like INSPIRE IDs)
for each unique raster value. Without RAT, raster cells contain only numeric
IDs (1, 2, 3...). With RAT, software like QGIS/R can display the IDs as
human-readable labels.

\strong{Format-specific behavior:}
\itemize{
\item \strong{GeoTIFF (.tif):} RAT stored in \code{.tif.aux.xml} sidecar file (XML).
\strong{Warning:} This sidecar can be \strong{larger than the TIFF itself} for large
grids. For chunked/streaming writes, requires a second pass (slower).
Consider NetCDF or KEA formats for large grids with labels.
\item \strong{NetCDF (.nc), KEA (.kea):} RAT embedded natively. \strong{Recommended}
for large grids requiring labels.
\item \strong{HDF5 (.hdf):} RAT \strong{not supported}. An error is raised if
\code{include_rat = TRUE}.
}}

\item{...}{Additional arguments passed to backend handlers.
When writing to text files (e.g., .csv, .tsv) via \code{dsn}, these arguments are passed to \code{\link[readr]{write_delim}} (e.g., \code{na = "NA"}, \code{quote = "all"}).
When writing to spatial files via \code{dsn}, these are passed to \code{\link[sf]{st_write}}.
For \code{output_type = "spatraster"} writing, these are passed to \code{\link[terra]{writeRaster}}.
For streaming backends (\code{mirai} or sequential), this can include \code{max_cells_per_chunk} to control memory usage.}

\item{grid_extent}{The spatial object defining the extent. Can be an \code{sf} object,
\code{sfc} geometry collection, \code{bbox}, \code{numeric} vector (as c(xmin, ymin, xmax, ymax)),
or \code{matrix}.}

\item{ids}{A character vector of INSPIRE-compliant grid cell IDs
(e.g., \code{"CRS3035RES100000mN26E43"}).}
}
\value{
If \code{dsn} is \code{NULL} (the default), an \code{sf} object, \code{data.frame},
or \code{SpatRaster} representing the grid. If \code{dsn} is specified, the function writes
the grid to a file and returns \code{invisible(dsn)}.

An \code{sf} object or \code{data.frame} representing the grid derived from
the INSPIRE IDs. If \code{dsn} is specified, returns \code{invisible(dsn)}.
}
\description{
Generates a standard-compliant spatial grid aligned to the CRS origin.
This function acts as a unified interface:
\itemize{
\item If \code{x} is a spatial object (extent), it creates a new grid (calling \code{\link{inspire_grid_from_extent}}).
\item If \code{x} is a character vector (INSPIRE IDs), it reconstructs the grid (calling \code{\link{inspire_grid_from_ids}}).
}

It combines high performance for large areas (using \code{sfheaders}) with a
flexible and robust set of features for input handling and output formatting,
including INSPIRE-compliant grid IDs and automatic parallel processing with
\code{mirai} and \code{future} backends.

This function takes a vector of INSPIRE-compliant IDs and derives a
regular spatial grid from it. For generating a spatial grid from a spatial
extent, see \code{\link{inspire_grid_from_extent}}.
}
\details{
This function creates a spatial grid aligned to the CRS origin, with support for
clipping to input geometries, parallel processing, and multiple output formats.
}
\examples{
library(sf)
# Load the sample data from the sf package
nc_raw <- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)

# Define target projected CRS and cell size
target_crs <- 5070 # NAD83 / Conus Albers
cellsize_m <- 10000 # 10 km

# Project the data
nc <- st_transform(nc_raw, target_crs)

# Create a grid covering the data
nc_grid <- inspire_grid_from_extent(
  grid_extent = nc,
  cellsize_m = cellsize_m,
  output_type = "sf_polygons",
  clip_to_input = TRUE
)

# Or using the S3 generic
nc_grid <- inspire_grid(nc, cellsize_m = cellsize_m, clip_to_input = TRUE)

head(nc_grid, 3)
library(sf)

inspire <- c(
  "CRS3035RES100000mN26E43", "CRS3035RES100000mN26E44",
  "CRS3035RES100000mN27E41", "CRS3035RES100000mN27E42",
  "CRS3035RES100000mN27E43", "CRS3035RES100000mN27E44"
)

grid <- inspire_grid_from_ids(inspire)
plot(grid$geometry)

# Or using the S3 generic
grid <- inspire_grid(inspire)
plot(grid$geometry)
}
